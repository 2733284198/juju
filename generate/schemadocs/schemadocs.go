// Copyright 2019 Canonical Ltd.
// Licensed under the AGPLv3, see LICENCE file for details.
package main

import (
	"encoding/json"
	"fmt"
	"html/template"
	"io/ioutil"
	"log"
	"os"
	"sort"
	"strings"
)

func main() {
	// the first argument here will be the name of the binary, so we ignore
	// argument 0 when looking for the filepath.
	if len(os.Args) != 2 {
		fmt.Fprintln(os.Stderr, "Expected one argument: filepath of json schema to read.")
		os.Exit(1)
	}

	data, err := ioutil.ReadFile(os.Args[1])
	if err != nil {
		log.Fatal(err)
	}

	var input []JSONFacade
	if err := json.Unmarshal(data, &input); err != nil {
		log.Fatal(err)
	}

	sort.Slice(input, func(i, j int) bool {
		f1, f2 := input[i], input[j]
		if f1.Name != f2.Name {
			return f1.Name < f2.Name
		}
		return f1.Version > f2.Version
	})

	output := make([]Facade, len(input))
	for k, facade := range input {
		methods := make([]FacadeMethod, 0, len(facade.Schema.Properties))
		for k, prop := range facade.Schema.Properties {
			methods = append(methods, FacadeMethod{
				Name:   k,
				Param:  prop.Properties.Params.Ref,
				Result: prop.Properties.Result.Ref,
			})
		}
		sort.Slice(methods, func(i, j int) bool {
			return methods[i].Name < methods[j].Name
		})

		definitions := make([]FacadeDefinition, 0, len(facade.Schema.Definitions))
		for k, prop := range facade.Schema.Definitions {
			definitions = append(definitions, FacadeDefinition{
				Name: k,
				Type: prop.Type,
				Ref:  fmt.Sprintf(""),
			})
		}
		sort.Slice(definitions, func(i, j int) bool {
			return definitions[i].Name < definitions[j].Name
		})

		output[k] = Facade{
			Name:        facade.Name,
			Version:     facade.Version,
			Methods:     methods,
			Definitions: definitions,
		}
	}

	t, err := template.New("").Funcs(tmplFuncs).Parse(htmlTmpl)
	if err != nil {
		log.Fatal(err)
	}
	if err := t.Execute(os.Stdout, output); err != nil {
		log.Fatal(err)
	}
}

type JSONFacade struct {
	Name    string
	Version int
	Schema  JSONFacadeSchema
}

type JSONFacadeSchema struct {
	Type        string                      `json:"type"`
	Properties  map[string]PropertySchema   `json:"properties"`
	Definitions map[string]DefinitionSchema `json:"definitions"`
}

type PropertySchema struct {
	Type       string   `json:"type"`
	Properties Property `json:"properties"`
}

type Property struct {
	Params Ref
	Result Ref
}

type Ref struct {
	Ref string `json:"$ref"`
}

type DefinitionSchema struct {
	Type                 string                      `json:"type"`
	Properties           map[string]DefinitionSchema `json:"properties"`
	AdditionalProperties bool                        `json:"additionalProperties"`
	Required             []string                    `json:"required"`
}

type Facade struct {
	Name        string
	Version     int
	Methods     []FacadeMethod
	Definitions []FacadeDefinition
}

type FacadeMethod struct {
	Name   string
	Param  string
	Result string
}

type FacadeDefinition struct {
	Name string
	Type string
	Ref  string
}

var htmlTmpl = `
<html>
<head>
<style>
	body {
		font-family: Ubuntu Light, sans-serif;
		padding: 25px;
	}
	h2 a {
		color: black;
		text-decoration: none;
	}
	h2 a:hover {
		text-decoration: underline;
	}
	h2 + p {
		padding-left: 25px;
	}
	table {
		margin: 50px 0;
	}
	tr:nth-child(even) {
		background-color: #f1f1f1;
	}
	td {
		vertical-align: top;
		padding: 10px;
	}
	hr {
		margin: 50px 0;
	}
</style>
<title>Juju API docs (autogenerated)</title>
</head>
<body>
<h1>Juju API facades</h1>
<p>
  The following are API facades for the Juju API. Each facade is versioned to
  ensure that backwards and forwards compatibility is achievable when using
  various versions of CLI and controllers.
</p>
<p>
  Although each facade in the API is versioned, the parameters are not, so
  it's worth noting that definitions could potentially break if removal or
  modifying a definition occurs between versions of Facades.
</p>
<ul>
{{range .}}
	<ul><a href="#{{.Name}}">{{.Name}}</a> v{{.Version}}</ul>
{{end}}
</ul>
<hr />
{{range .}}
   {{$facade_name:=.Name}}
	<h2 id="{{.Name}}"><a href="#{{.Name}}">{{.Name}}</a> v{{.Version}}</h2>
	<ul>
	  <li><a href="#{{.Name}}_definitions">Definitions</a></li>
	</ul>
	<table>
		<tr>
			<th>Name</th>
			<th>Params</th>
			<th>Results</th>
		</tr>
		{{range .Methods}}
		<tr>
			<td>{{.Name}}</td>
			<td><a href="#{{$facade_name}}_{{.Param | defLink}}">{{.Param | defName}}</a></td>
			<td><a href="#{{$facade_name}}_{{.Result | defLink}}">{{.Result | defName}}</a></td>
		</tr>
		{{end}}
	</table>
	<h3 id="{{.Name}}_definitions"><a href="#{{.Name}}_definitions">{{.Name}} Definitions</a></h3>
	<ul>
	  <li><a href="#{{.Name}}">Methods</a></li>
	</ul>
	<table>
		<tr>
			<th>Name</th>
			<th>Type</th>
		</tr>
		{{range .Definitions}}
		<tr>
			<td><a href="#{{$facade_name}}_definitions_{{.Name}}" id="{{$facade_name}}_definitions_{{.Name}}">{{.Name}}</td>
			<td>{{.Type}}</td>
		</tr>
		{{end}}
	</table>
	<hr />
{{end}}
</body>
</html>
`

var tmplFuncs = template.FuncMap{
	"join": func(sep string, ss []string) string {
		return strings.Join(ss, sep)
	},
	"defLink": func(name string) string {
		if strings.HasPrefix(name, "#/") {
			name = name[2:]
		}
		return strings.ReplaceAll(name, "/", "_")
	},
	"defName": func(name string) string {
		return strings.TrimPrefix(name, "#/definitions/")
	},
}
