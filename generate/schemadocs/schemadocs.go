// Copyright 2019 Canonical Ltd.
// Licensed under the AGPLv3, see LICENCE file for details.
package main

import (
	"encoding/json"
	"fmt"
	"html/template"
	"io/ioutil"
	"log"
	"os"
	"sort"
	"strings"
)

func main() {
	// the first argument here will be the name of the binary, so we ignore
	// argument 0 when looking for the filepath.
	if len(os.Args) != 2 {
		fmt.Fprintln(os.Stderr, "Expected one argument: filepath of json schema to read.")
		os.Exit(1)
	}

	data, err := ioutil.ReadFile(os.Args[1])
	if err != nil {
		log.Fatal(err)
	}

	var input []JSONFacade
	if err := json.Unmarshal(data, &input); err != nil {
		log.Fatal(err)
	}

	sort.Slice(input, func(i, j int) bool {
		f1, f2 := input[i], input[j]
		if f1.Name != f2.Name {
			return f1.Name < f2.Name
		}
		return f1.Version > f2.Version
	})

	output := make([]Facade, len(input))
	for k, facade := range input {
		methods := make([]FacadeMethod, 0, len(facade.Schema.Properties))
		for k, prop := range facade.Schema.Properties {

			paramRef := prop.Properties.Params.Ref
			resultRef := prop.Properties.Result.Ref

			methods = append(methods, FacadeMethod{
				Name:       k,
				ParamName:  strings.TrimPrefix(paramRef, "#/definitions/"),
				ParamRef:   strings.ReplaceAll(paramRef, "/", "_"),
				ResultName: strings.TrimPrefix(resultRef, "#/definitions/"),
				ResultRef:  strings.ReplaceAll(resultRef, "/", "_"),
			})
		}

		sort.Slice(methods, func(i, j int) bool {
			return methods[i].Name < methods[j].Name
		})

		output[k] = Facade{
			Name:    facade.Name,
			Version: facade.Version,
			Methods: methods,
		}
	}

	t, err := template.New("").Funcs(tmplFuncs).Parse(htmlTmpl)
	if err != nil {
		log.Fatal(err)
	}
	if err := t.Execute(os.Stdout, output); err != nil {
		log.Fatal(err)
	}
}

type JSONFacade struct {
	Name    string
	Version int
	Schema  JSONFacadeSchema
}

type JSONFacadeSchema struct {
	Type       string                    `json:"type"`
	Properties map[string]PropertySchema `json:"properties"`
}

type PropertySchema struct {
	Type       string   `json:"type"`
	Properties Property `json:"properties"`
}

type Property struct {
	Params Ref
	Result Ref
}

type Ref struct {
	Ref string `json:"$ref"`
}

type Facade struct {
	Name    string
	Version int
	Methods []FacadeMethod
}

type FacadeMethod struct {
	Name       string
	ParamName  string
	ParamRef   string
	ResultName string
	ResultRef  string
}

var htmlTmpl = `
<html>
<head>
<style>
	body {
		font-family: Ubuntu Light, sans-serif;
		padding: 25px;
	}
	h2 a {
		color: black;
		text-decoration: none;
	}
	h2 a:hover {
		text-decoration: underline;
	}
	h2 + p {
		padding-left: 25px;
	}
	tr:nth-child(even) {
		background-color: #f1f1f1;
	}
	td {
		vertical-align: top;
		padding: 10px;
	}
</style>
<title>Juju API docs (autogenerated)</title>
</head>
<body>
<h1>Juju API facades</h1>
{{range .}}
	<h2 id="{{.Name}}"><a href="#{{.Name}}">{{.Name}}</a> v{{.Version}}</h2>
	<table>
		<tr>
			<th>Name</th>
			<th>Params</th>
			<th>Results</th>
		</tr>
		{{range .Methods}}
		<tr>
			<td>{{.Name}}</td>
			<td><a href="{{.ParamRef}}">{{.ParamName}}</a></td>
			<td><a href="{{.ResultRef}}">{{.ResultName}}</a></td>
		</tr>
		{{end}}
	</table>
{{end}}
</body>
</html>
`

var tmplFuncs = template.FuncMap{
	"join": func(sep string, ss []string) string {
		return strings.Join(ss, sep)
	},
}
