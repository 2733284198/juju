// Copyright 2019 Canonical Ltd.
// Licensed under the AGPLv3, see LICENCE file for details.
package main

import (
	"encoding/json"
	"fmt"
	"html/template"
	"io/ioutil"
	"log"
	"os"
	"sort"
	"strings"
)

func main() {
	// the first argument here will be the name of the binary, so we ignore
	// argument 0 when looking for the filepath.
	if len(os.Args) != 2 {
		fmt.Fprintln(os.Stderr, "Expected one argument: filepath of json schema to read.")
		os.Exit(1)
	}

	data, err := ioutil.ReadFile(os.Args[1])
	if err != nil {
		log.Fatal(err)
	}

	var input []JSONFacade
	if err := json.Unmarshal(data, &input); err != nil {
		log.Fatal(err)
	}

	sort.Slice(input, func(i, j int) bool {
		f1, f2 := input[i], input[j]
		if f1.Name != f2.Name {
			return f1.Name < f2.Name
		}
		return f1.Version > f2.Version
	})

	output := make([]TemplateFacade, len(input))
	for k, facade := range input {
		methods := make([]TemplateMethod, 0, len(facade.Schema.Properties))
		for k, prop := range facade.Schema.Properties {
			methods = append(methods, TemplateMethod{
				Name:   k,
				Param:  prop.Properties.Params.Ref,
				Result: prop.Properties.Result.Ref,
			})
		}
		sort.Slice(methods, func(i, j int) bool {
			return methods[i].Name < methods[j].Name
		})

		definitions := make([]TemplateDefinition, 0, len(facade.Schema.Definitions))
		for k, prop := range facade.Schema.Definitions {
			properties := make([]TemplateProperty, 0, len(prop.Properties))
			for k, v := range prop.Properties {
				properties = append(properties, TemplateProperty{
					Name:   k,
					Type:   v.Type,
					Format: v.Format,
					Ref:    "",
				})
			}
			sort.Slice(properties, func(i, j int) bool {
				return properties[i].Name < properties[j].Name
			})

			definitions = append(definitions, TemplateDefinition{
				Name:       k,
				Type:       prop.Type,
				Properties: properties,
			})
		}
		sort.Slice(definitions, func(i, j int) bool {
			return definitions[i].Name < definitions[j].Name
		})

		output[k] = TemplateFacade{
			Name:        facade.Name,
			Version:     facade.Version,
			Methods:     methods,
			Definitions: definitions,
		}
	}

	t, err := template.New("").Funcs(tmplFuncs).Parse(htmlTmpl)
	if err != nil {
		log.Fatal(err)
	}
	if err := t.Execute(os.Stdout, output); err != nil {
		log.Fatal(err)
	}
}

// JSONFacade represents the facade in json schema form
type JSONFacade struct {
	Name    string
	Version int
	Schema  JSONFacadeSchema
}

// JSONFacadeSchema represents the facade schema object in json schema form
type JSONFacadeSchema struct {
	Type        string                      `json:"type"`
	Properties  map[string]PropertySchema   `json:"properties"`
	Definitions map[string]DefinitionSchema `json:"definitions"`
}

// PropertySchema represents the property schema object in json schema form
type PropertySchema struct {
	Type       string   `json:"type"`
	Properties Property `json:"properties"`
}

// Property represents the property object in json schema form
type Property struct {
	Params Ref
	Result Ref
}

// Ref represents a reference to another object
type Ref struct {
	Ref string `json:"$ref"`
}

// DefinitionSchema represents a definition in json schema form
type DefinitionSchema struct {
	Ref
	Type                 string                      `json:"type"`
	Format               string                      `json:"format"`
	Properties           map[string]DefinitionSchema `json:"properties"`
	AdditionalProperties bool                        `json:"additionalProperties"`
	Required             []string                    `json:"required"`
}

// TemplateFacade represents a facade for templating usage
type TemplateFacade struct {
	Name        string
	Version     int
	Methods     []TemplateMethod
	Definitions []TemplateDefinition
}

// TemplateMethod represents a facade method for templating usage
type TemplateMethod struct {
	Name   string
	Param  string
	Result string
}

// TemplateDefinition represents a facade definition for templating usage
type TemplateDefinition struct {
	Name       string
	Type       string
	Properties []TemplateProperty
}

type TemplateProperty struct {
	Name   string
	Type   string
	Format string
	Ref    string
}

var htmlTmpl = `
<html>
<head>
<style>
	body {
		font-family: Ubuntu Light, sans-serif;
		padding: 25px;
	}
	h2 a {
		color: black;
		text-decoration: none;
	}
	h2 a:hover {
		text-decoration: underline;
	}
	h2 + p {
		padding-left: 25px;
	}
	table {
		margin: 0 0 50px 0;
		width: 100%;
	}
	tr:nth-child(even) {
		background-color: #f1f1f1;
	}
	td {
		vertical-align: top;
		padding: 10px;
	}
	hr {
		margin: 50px 0;
	}
</style>
<title>Juju API docs (autogenerated)</title>
</head>
<body>
<h1>Juju API facades</h1>
<p>
  The following are API facades for the Juju API. Each facade is versioned to
  ensure that backwards and forwards compatibility is achievable when using
  various versions of CLI and controllers.
</p>
<p>
  Although each facade in the API is versioned, the parameters are not, so
  it's worth noting that definitions could potentially break if removal or
  modifying a definition occurs between versions of Facades.
</p>
<ul>
{{range .}}
	<ul><a href="#{{.Name}}">{{.Name}}</a> v{{.Version}}</ul>
{{end}}
</ul>
<hr />
{{range .}}
   {{$facade_name:=.Name}}
	<h2 id="{{.Name}}"><a href="#{{.Name}}">{{.Name}}</a> v{{.Version}}</h2>
	<ul>
	  <li><a href="#{{.Name}}_definitions">Definitions</a></li>
	</ul>
	<table>
		<tr>
			<th>Name</th>
			<th>Params</th>
			<th>Results</th>
		</tr>
		{{range .Methods}}
		<tr>
			<td>{{.Name}}</td>
			<td><a href="#{{$facade_name}}_{{.Param | defLink}}">{{.Param | defName}}</a></td>
			<td><a href="#{{$facade_name}}_{{.Result | defLink}}">{{.Result | defName}}</a></td>
		</tr>
		{{end}}
	</table>
	<h3 id="{{.Name}}_definitions"><a href="#{{.Name}}_definitions">{{.Name}} Definitions</a></h3>
	<ul>
	  <li><a href="#{{.Name}}">Methods</a></li>
	</ul>
	{{range .Definitions}}
	<h4 id="{{$facade_name}}_definitions_{{.Name}}"><a href="#{{$facade_name}}_definitions_{{.Name}}">{{.Name}}</a></h4>
	<table>
		<tr>
			<th>Name</th>
			<th>Type</th>
			<th>Format</th>
			<th>Reference</th>
		</tr>
		{{range .Properties}}
		<tr>
			<td>{{.Name}}</td>
			<td>{{.Type | typeRef .Ref}}</td>
			<td>{{.Format}}</td>
			<td>{{.Ref}}</td>
		</tr>
		{{end}}
	</table>
	{{end}}
	<hr />
{{end}}
</body>
</html>
`

var tmplFuncs = template.FuncMap{
	"join": func(sep string, ss []string) string {
		return strings.Join(ss, sep)
	},
	"defLink": func(name string) string {
		if strings.HasPrefix(name, "#/") {
			name = name[2:]
		}
		return strings.ReplaceAll(name, "/", "_")
	},
	"defName": func(name string) string {
		return strings.TrimPrefix(name, "#/definitions/")
	},
	"typeRef": func(t, ref string) string {
		if strings.HasPrefix(ref, "#/") {
			return "Ref"
		}
		return t
	},
}
